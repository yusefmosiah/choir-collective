# AI Model Re-Entry Guide

VERSION reentry_prompt:
invariants: {
"Event coherence",
"Pattern recognition",
"Natural flow"
}
assumptions: {
"AI model capabilities",
"Documentation context",
"System understanding"
}
docs_version: "0.3.0"

You are being provided with the Choir codebase and documentation. This system has evolved from a web/React architecture to an event-driven, local-first Swift implementation. Your task is to understand and work within this architecture while maintaining system coherence.

## Core Architecture

The system operates through:

Event-Driven Flow
- Local events create waves of state change
- Chain events provide state authority
- Vector events handle content/embeddings
- Events flow naturally through the system

Actor-Based Isolation
- Each domain lives in its own actor
- Actors communicate through events
- State remains properly isolated
- Resources cleanly managed

Local-First Design
- SwiftData for local events
- Chain for state authority
- Qdrant for content/embeddings
- Natural sync patterns

## Key Components

Chorus Cycle
- AEIOU-Y step sequence
- Event-driven transitions
- Effect accumulation
- Prior flow
- Natural evolution

Value Creation
- Quality emerges through events
- Teams form through resonance
- Value crystallizes at nodes
- Knowledge grows naturally
- System evolves coherently

Pattern Recognition
- Events reveal patterns
- Teams recognize value
- Knowledge accumulates
- Understanding grows
- Evolution emerges

## Development Priorities

1. Event Integrity
- Clean event types
- Proper handling
- Local persistence
- Natural flow

2. Pattern Emergence
- Event analysis
- Pattern tracking
- Value evolution
- System growth

3. State Coherence
- Local-first state
- Chain verification
- Pattern recognition
- Natural evolution

## Working with the System

When examining code or documentation:

1. Look For
- Event patterns
- Actor isolation
- Local-first design
- Natural evolution
- System coherence

2. Maintain
- Event integrity
- Pattern recognition
- Value preservation
- Natural flow
- System growth

3. Enable
- Quality emergence
- Team formation
- Value crystallization
- Knowledge growth
- Pattern evolution

## Implementation Guide

When implementing features:

1. Start with Events
- Define event types
- Plan event flow
- Enable natural patterns
- Maintain coherence

2. Use Actors
- Proper isolation
- Event-based communication
- Resource management
- Pattern emergence

3. Think Local-First
- SwiftData for events
- Chain for authority
- Natural sync
- Pattern evolution

Your role is to:
1. Understand the event-driven patterns
2. Maintain actor isolation
3. Follow local-first design
4. Enable natural evolution
5. Preserve system coherence

The system will guide you through:
- Event patterns
- Natural flow
- Value creation
- Pattern emergence
- System evolution
